import CoreImage
import Foundation

class LUTGenerator {
    static func generateLUT(
        from adjustments: ImageAdjustments,
        sourceImage _: CIImage?,
        size: Int = 64
    ) async -> CIImage? {
        // 创建一个identity LUT图像
        guard let identityLUT = createIdentityLUT(size: size) else {
            return nil
        }

        print("LUTGenerator: Identity LUT 创建成功，尺寸: \(identityLUT.extent)")

        // 应用所有调整到identity LUT
        let adjustedLUT = await ImageProcessor.applyAdjustments(
            to: identityLUT,
            adjustments: adjustments
        )

        print("LUTGenerator: 调整应用完成")

        return adjustedLUT
    }

    static func saveLUTToCube(
        lutImage: CIImage,
        to url: URL,
        size: Int = 64
    ) throws {
        let context = CIContext(options: [
            .workingColorSpace: CGColorSpace(name: CGColorSpace.sRGB)!,
            .outputColorSpace: CGColorSpace(name: CGColorSpace.sRGB)!,
        ])

        // 渲染LUT图像到bitmap
        let width = size * size
        let height = size
        var bitmap = [Float](repeating: 0, count: width * height * 4)

        let extent = CGRect(x: 0, y: 0, width: width, height: height)

        context.render(
            lutImage,
            toBitmap: &bitmap,
            rowBytes: width * 4 * MemoryLayout<Float>.size,
            bounds: extent,
            format: .RGBAf,
            colorSpace: CGColorSpace(name: CGColorSpace.sRGB)
        )

        print("LUTGenerator: 渲染完成，开始写入.cube文件")

        // 写入.cube文件
        var cubeContent = "# Generated by RawKit\n"
        cubeContent += "# LUT size\n"
        cubeContent += "LUT_3D_SIZE \(size)\n"
        cubeContent += "DOMAIN_MIN 0.0 0.0 0.0\n"
        cubeContent += "DOMAIN_MAX 1.0 1.0 1.0\n\n"

        // 按照.cube格式写入数据
        // .cube格式：对于每个蓝色值，遍历所有绿色值，对于每个绿色值遍历所有红色值
        for b in 0 ..< size {
            for g in 0 ..< size {
                for r in 0 ..< size {
                    // 计算在bitmap中的位置
                    let x = b * size + r
                    let y = g
                    let index = (y * width + x) * 4

                    let red = max(0, min(1, bitmap[index]))
                    let green = max(0, min(1, bitmap[index + 1]))
                    let blue = max(0, min(1, bitmap[index + 2]))

                    cubeContent += String(format: "%.6f %.6f %.6f\n", red, green, blue)
                }
            }
        }

        try cubeContent.write(to: url, atomically: true, encoding: .utf8)
        print("LUTGenerator: .cube文件写入成功")
    }

    private static func createIdentityLUT(size: Int) -> CIImage? {
        let width = size * size
        let height = size

        print("LUTGenerator: 开始创建 identity LUT，size=\(size), 图像尺寸=\(width)x\(height)")

        // 创建identity LUT的像素数据
        var pixels = [Float](repeating: 0, count: width * height * 4)

        for b in 0 ..< size {
            for g in 0 ..< size {
                for r in 0 ..< size {
                    let x = b * size + r
                    let y = g
                    let index = (y * width + x) * 4

                    // Identity LUT：输出 = 输入
                    let normR = Float(r) / Float(size - 1)
                    let normG = Float(g) / Float(size - 1)
                    let normB = Float(b) / Float(size - 1)

                    pixels[index] = normR // R
                    pixels[index + 1] = normG // G
                    pixels[index + 2] = normB // B
                    pixels[index + 3] = 1.0 // A
                }
            }
        }

        // 验证几个采样点
        print("LUTGenerator: 采样点验证 - (0,0,0): (\(pixels[0]), \(pixels[1]), \(pixels[2]))")
        let midIndex = ((size / 2) * width + (size / 2) * size + (size / 2)) * 4
        print(
            "LUTGenerator: 采样点验证 - 中点: (\(pixels[midIndex]), \(pixels[midIndex + 1]), \(pixels[midIndex + 2]))"
        )

        // 创建CIImage
        let data = Data(bytes: pixels, count: pixels.count * MemoryLayout<Float>.size)

        let image = CIImage(
            bitmapData: data,
            bytesPerRow: width * 4 * MemoryLayout<Float>.size,
            size: CGSize(width: width, height: height),
            format: .RGBAf,
            colorSpace: CGColorSpace(name: CGColorSpace.sRGB)
        )

        return image
    }
}
